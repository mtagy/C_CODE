#include <stdio.h>
int main()
{ //有序数组找具体数字 二分查找法 效率高
    // 1.找中间元素下标mid (找出数组左边元素下标和右边元素的下标 中间元素下标是最左边元素left和最右边元素right下标的平均值)
    // 2.比较,不相等就修改right或者left（修改范围）
    // eg:arr[]={1,2,3,4,5,6,7,8,9,10}中找7
    //（0+9）/2=4 整数除法 中间元素下标为4 arr[4]=5<7(要找的数字7在5的右边) 查找一次，查找范围缩小一半(数据少了一半)
    //右下标不变，左下标变成mid+1 新范围：5~9   (重复1，2步骤直至找到)
    //新中间元素下标 mid=(5+9)/2=7 arr[7]=8>7(要找的数字7在8的左边)  左下标不变 右下标变成mid-1 新范围：5~6
    //新中间元素下标 mid=(5+6)/2=5 arr[5]=6<7(要找的数字7在6的右边) 右下标不变，左下标变成mid+1 新范围：只有下标6了(左右下标重合）
    // arr[6]=7 找到数字7 如果此时arr[6]!=7 就找不到数字7了
    //顺序查找：最坏情况查找10次  二分查找最坏情况是要查找的元素可能位于数组的边缘位置，比如第一个或最后一个位置，或者数组中不存在要查找的元素。
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int k = 7; //要找数字7

    int sz = sizeof(arr) / sizeof(arr[0]);
    int left = 0;
    int right = sz - 1;

    while (left <= right) // left<=right 还有元素进行查找
    {
        int mid = (left + right) / 2;
        if (arr[mid] < k)
        {
            left = mid + 1;
        }
        else if (arr[mid] > k)
        {
            right = mid - 1;
        }
        else
        {
            printf("找到了，下标是%d\n", mid);
            break;
        }
    }

    if (left > right) // left>right 没有元素进行查找 找不到了
    {
        printf("找不到了");
    }
    return 0;
}