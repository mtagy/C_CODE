#include <stdio.h>
//方法1
/*int count_1(unsigned int n)
{ // 10 二进制：1010   十进制 %10 /10取出十进制每一位  1234   二进制：%2 /2 得到二进制每一位
	// 10%2=0  10/2=5  5%2=1  5/2=2  2%2=0  2/2=1  1%2=1  1/2=0
	//取出二进制的每一位就是取模的值  从最后一位开始
	int count = 0;
	while (n)
	{
		if (n % 2 == 1)
			count++;
		n /= 2;
	}
	return count;
}*/
//问题：输入负整数出错
// eg  -1
// 10000000 00000000 00000000 00000001原码
// 11111111 11111111 11111111 11111110 反码
// 11111111 11111111 11111111 11111111 补码
//补码中32个1  按理说应该会输出32 结果却输出0
//改进：形参设置为无符号类型 将传递过来的-1 的补码看成很大的正数(第一位不再看成符号位)

//方法2    负数整数都行
/*int count_1(int n)
{
	int count = 0, i = 0;
	for (i = 0; i < 32; i++)
	{
		if ((n >> 1) & 1 == 1)
			//把数字n的二进制数的每一位移到到最低位 &1判断1/0
			count++;
	}
	return count;
}*/

//法1法2效率不高

//方法3
// n=15 
// n=n&(n-1)
//1111  n
//1110  n-1
//1110  n
//1101  n-1
//1100  n
//1011  n-1
//1000  n
//0111  n-1
//0000  n     发现每进行一次按位与就会消失一个1  统计1的个数,可以看这个表达式执行几次即可
//只关注1的个数  效率高

int count_1(int n)
{
	int count = 0;
	while (n)
	{
		n = n & (n - 1);
		count++;
	}
	return count;
}
//如果想判断一个数是否为2^n
//2^1  2  0010
//2^2  4  0100
//2^3  8  1000  发现2^n中二进制序列始终只有一个1
//if(n&(n-1)==0)  ===>n就是2^n  (n&(n-1)执行一次去掉一个1，而2^n只有一个1) 

int main()
{ //统计二进制中1的个数
	int n;
	scanf("%d", &n);
	int m = count_1(n);
	printf("%d\n", m);
	return 0;
}