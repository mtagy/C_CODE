#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
/*int main()//方法一
{
	int  a = 1;
	if (*(char*)&a == 1)
		printf("小端\n");
	else
		printf("大端\n");
	return 0;
}*/
//方法二：函数
/*int check_sys()
{
	int a = 1;
	return *(char*)&a;

}
int main()
{
	int ret = check_sys();
	if (ret == 1)
		printf("小端\n");
	else
		printf("大端\n");
	return 0;
}*/
/*#include <stdio.h>
int main()
{
	char a = -1;
	signed char b = -1;
	unsigned char c = -1;
	printf("%d %d %d\n", a, b, c);
	return 0;
}*/
/*#include <stdio.h>
int main()
{
	char a = -128;//-128~127  有符号char范围
	//10000000  00000000 00000000  10000000 原码
	//11111111  11111111 11111111  01111111 反码
	//11111111  11111111 11111111  10000000 补码
	//存入1byte大小的字符型变量a发生截断，只存了低8位
	//10000000
	//%u打印无符号整型  需要发生整型提升 char有符号变量  最高位是符号位1 高位补1
	//整型提升后：11111111  11111111 11111111  10000000 补码
	//%u认为这个补码是无符号数  即正数  正数原码和补码一样  打印输出一个很大的数

	//%d认为这个补码是有符号数
	//10000000  00000000 00000000  10000000 原码 ===> -128
	printf("%u\n", a);//4294967168
	printf("%d\n", a);//-128

	//%u打印无符号整数
	return 0;
}*/

/*#include <stdio.h>
int main()
{
	char a = 128;
	//00000000 00000000 00000000 10000000 原码 反码 补码
	//字符型变量  整数存入会发生截断  低8位：10000000
	//%u 打印无符号整数 会发生整型提升 char有符号数  最高位符号位1  高位补1
	//整型提升后：
	//11111111 11111111 11111111 10000000 补码
	//%u认为这个补码是无符号数 即正数  打印输出一个很大的数
	//%d认为这个补码是有符号数 即负数
	//10000000 00000000 00000000 01111111 反码
	//10000000 00000000 00000000 10000000 原码 ===> -128
	printf("%u\n", a);//4294967168
	printf("%d\n", a);// -128
	return 0;
}*/

/*#include <stdio.h>

int main()
{
	int i = -20;
	//10000000 00000000 00000000 00010100 原码
	//11111111 11111111 11111111 11101011 反码
	//11111111 11111111 11111111 11101100 补码
	unsigned int j = 10;
	//00000000 00000000 00000000 00001010 原码 反码 补码
	printf("%d\n", i + j);//-10
	//11111111 11111111 11111111 11101100
	// +
	//00000000 00000000 00000000 00001010
	//11111111 11111111 11111111 11110110 补码
	//%d认为这个补码是有符号数 转换为原码
	//10000000 00000000 00000000 00001010 原码  -10
	return 0;
}*/

/*#include <stdio.h>
#include <windows.h>

int main()
{
	unsigned int i;
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);//没有负数 没有符号位所有位都是有效位
		//i=0---> i--   ---> i=-1
		//10000000 00000000 00000000 00000001 原码
		//11111111 11111111 11111111 11111110 反码
		//11111111 11111111 11111111 11111111 补码
		//%u认为这个补码是一个无符号数， 即非常大的一个正数  >=0 依旧成立  会一直输出   i-- -2的补码%u认为是一个很大的正数
		//死循环输出
		Sleep(1000);//休眠1000ms,方便观察
	}
	return 0;
}*/

/*#include <stdio.h>
int main()
{
	char a[1000];
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}//-1 -2 -3 …… -1000 int
	//a[i] char  取值范围-128~127
	//-1 -2 -3 -4……-128 127 126 125 ……4 3 2 1 0 -1 -2……
	printf("%d", strlen(a));//128+127=255
	//strlen是求字符串的长度 关注的是字符串中'\0'（ASCII:数字0）之前出现多少个字符
	return 0;
}*/

/*#include <stdio.h>
unsigned char i = 0;//无符号char取值范围： 0~255
int main()
{
	for (i = 0; i <= 255; i++) //i<=255恒成立 死循环
	{
		printf("hello world\n");
		//256
		//00000000 00000000 00000001 00000000
		//存入字符型变量产生截断只保存低8位：00000000
		//进行整型提升：无符号 高位补0
		//00000000 00000000 00000000 00000000  ===>0    <=255
		//257同理 i<=255恒成立 死循环
	}
	return 0;
}*/

/*#include<stdio.h>
#include<string.h>
int main()
{
	if (strlen("abc") - strlen("abcdef") >= 0)
		printf(">\n");//>
	else
		printf("<\n");
	return 0;
}*/
//strlen()返回值类型是size_t--->unsigned int 求出的字符串长度不可能是负数
//3-6=-3  
//10000000 00000000 00000000 00000011 原码
//11111111 11111111 11111111 11111100
//11111111 11111111 11111111 11111101 补码
//这个补码被认为是无符号数 即一个很大的正数 >=0成立，输出>

/*#include<stdio.h>
int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为: %d\n", n);
	printf("*pFloat的值为: %f\n", *pFloat);
	*pFloat = 9.0;
	printf("num的值为: %d\n", n);
	printf("*pFloat的值为: %f\n", *pFloat);
	return 0;
}*/

/*#include <stdio.h>
int main()
{
	float f = 5.5f;
	//5.5
	//101.1
	//1.011*2^2
	//S=0 M=1.011 E=2
	//0 10000001 01100000000000000000000 ===>0x40 B0 00 00
	//2+127=129 10000001
	//M只保存小数点后面的部分 不够23位补0
	//float 4byte(>1byte)涉及大小端问题
	//VS 小端字节型存储
	return 0;
}*/
